package in.handyman.raven.lib;

import in.handyman.raven.exception.HandymanException;
import in.handyman.raven.lambda.access.ResourceAccess;
import in.handyman.raven.lambda.action.ActionExecution;
import in.handyman.raven.lambda.action.IActionExecution;
import in.handyman.raven.lambda.doa.audit.ActionExecutionAudit;
import in.handyman.raven.lib.model.AssetInfo;
import in.handyman.raven.util.CommonQueryUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import okhttp3.OkHttpClient;
import org.apache.commons.io.FilenameUtils;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import static java.lang.Math.random;

/**
 * Auto Generated By Raven
 */
@ActionExecution(
        actionName = "AssetInfo"
)
public class AssetInfoAction implements IActionExecution {
    private final ActionExecutionAudit action;

    private final Logger log;

    private final AssetInfo assetInfo;

    private final Marker aMarker;

    public AssetInfoAction(final ActionExecutionAudit action, final Logger log,
                           final Object assetInfo) {
        this.assetInfo = (AssetInfo) assetInfo;
        this.action = action;
        this.log = log;
        this.aMarker = MarkerFactory.getMarker(" AssetInfo:" + this.assetInfo.getName());
    }

    @Override
    public void execute() throws Exception {
        try {
            log.info(aMarker, "<-------Asset Info Action for {} has been started------->" + assetInfo.getName());
            final OkHttpClient httpclient = new OkHttpClient.Builder()
                    .connectTimeout(10, TimeUnit.MINUTES)
                    .writeTimeout(10, TimeUnit.MINUTES)
                    .readTimeout(10, TimeUnit.MINUTES).build();
            final Jdbi jdbi = ResourceAccess.rdbmsJDBIConn(assetInfo.getResourceConn());
            final List<Map<String, Object>> tableInfos = new ArrayList<>();

            jdbi.useTransaction(handle -> {
                final List<String> formattedQuery = CommonQueryUtil.getFormattedQuery(assetInfo.getValues());
                formattedQuery.forEach(sqlToExecute -> {
                    tableInfos.addAll(handle.createQuery(sqlToExecute).mapToMap().stream().collect(Collectors.toList()));
                });
            });
            List<Path> pathList = new ArrayList<>();
            for (var tableInfo : tableInfos) {
                final String tenantIdString = Optional.ofNullable(tableInfo.get("tenant_id")).map(String::valueOf).orElse("[]");
                final String templateIdString = Optional.ofNullable(tableInfo.get("template_id")).map(String::valueOf).orElse("[]");
                final String createdUserIdString = Optional.ofNullable(tableInfo.get("created_user_id")).map(String::valueOf).orElse("[]");
                final String lastUpdatedUserIdString = Optional.ofNullable(tableInfo.get("last_updated_user_id")).map(String::valueOf).orElse("[]");
                final String filePathString = Optional.ofNullable(tableInfo.get("file_path")).map(String::valueOf).orElse("[]");
                final String originIdString = Optional.ofNullable(tableInfo.get("origin_id")).map(String::valueOf).orElse("[]");

                try (var files = Files.walk(Path.of(filePathString)).filter(Files::isRegularFile)) {
                    files.forEach(pathList::add);
                }
                pathList.forEach(path -> {
                    File file = new File(path.toUri());
                    String sha1Hex;
                    try (InputStream is = Files.newInputStream(Path.of(file.getPath()))) {
                        sha1Hex = org.apache.commons.codec.digest.DigestUtils.sha1Hex(is);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }

                    var fileSize = file.length() / 1024;
                    FileInfo fileInfo = FileInfo.builder()
                            .file_checksum(sha1Hex)
                            .file_extension(FilenameUtils.getExtension(file.getName()))
                            .file_name(FilenameUtils.removeExtension(file.getName()))
                            .file_path(file.getPath())
                            .file_size(String.valueOf(fileSize))
                            .root_pipeline_id(action.getContext().get("pipeline-id"))
                            .process_id(action.getContext().get("process-id"))
                            .build();

                    jdbi.useTransaction(handle -> {
                        handle.createUpdate("INSERT INTO macro.file_details(process_id,root_pipeline_id, file_checksum, file_extension, file_name, file_path, file_size)" +
                                        "VALUES(:process_id, :root_pipeline_id, :file_checksum, :file_extension, :file_name, :file_path, :file_size);")
                                .bindBean(fileInfo).execute();
                        log.debug(aMarker, "inserted {} into source of origin", fileInfo);
                    });
                });
            }


        } catch (Exception e) {
            action.getContext().put(assetInfo.getName().concat(".error"), "true");
            log.info(aMarker, "The Exception occurred ", e);
            throw new HandymanException("Failed to execute", e);
        }
        log.info(aMarker, "<-------Asset Info Action for {} has been completed------->" + assetInfo.getName());
    }

    @Override
    public boolean executeIf() throws Exception {
        return assetInfo.getCondition();
    }


    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class FileInfo {
        private String process_id;
        private String root_pipeline_id;
        private String file_checksum;
        private String file_extension;
        private String file_name;
        private String file_path;
        private String file_size;
    }
}
